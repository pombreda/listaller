/* buildlist.c generated by valac 0.12.0, the Vala compiler
 * generated from buildlist.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <glib/gstdio.h>
#include <gio/gio.h>
#include <gee.h>


#define TYPE_VERSION_NUMBER (version_number_get_type ())
#define VERSION_NUMBER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_VERSION_NUMBER, VersionNumber))
#define VERSION_NUMBER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_VERSION_NUMBER, VersionNumberClass))
#define IS_VERSION_NUMBER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_VERSION_NUMBER))
#define IS_VERSION_NUMBER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_VERSION_NUMBER))
#define VERSION_NUMBER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_VERSION_NUMBER, VersionNumberClass))

typedef struct _VersionNumber VersionNumber;
typedef struct _VersionNumberClass VersionNumberClass;
typedef struct _VersionNumberPrivate VersionNumberPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))

struct _VersionNumber {
	GObject parent_instance;
	VersionNumberPrivate * priv;
};

struct _VersionNumberClass {
	GObjectClass parent_class;
};

struct _VersionNumberPrivate {
	gint _major;
	gint _minor;
	gint _revision;
	gchar* originalString;
};


static gpointer version_number_parent_class = NULL;

GType version_number_get_type (void) G_GNUC_CONST;
#define VERSION_NUMBER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_VERSION_NUMBER, VersionNumberPrivate))
enum  {
	VERSION_NUMBER_DUMMY_PROPERTY
};
VersionNumber* version_number_new (const gchar* version);
VersionNumber* version_number_construct (GType object_type, const gchar* version);
static void version_number_set_major (VersionNumber* self, gint value);
static void version_number_set_minor (VersionNumber* self, gint value);
static void version_number_set_revision (VersionNumber* self, gint value);
gboolean version_number_newerThan (VersionNumber* self, VersionNumber* other);
static gint version_number_get_major (VersionNumber* self);
static gint version_number_get_minor (VersionNumber* self);
static gint version_number_get_revision (VersionNumber* self);
gchar* version_number_getString (VersionNumber* self);
static void version_number_finalize (GObject* obj);
static void _vala_version_number_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_version_number_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
gint _vala_main (gchar** args, int args_length1);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


VersionNumber* version_number_construct (GType object_type, const gchar* version) {
	VersionNumber * self = NULL;
	gchar* _tmp0_;
	GRegex* _tmp1_ = NULL;
	GRegex* regex;
	gchar** _tmp2_;
	gchar** _tmp3_ = NULL;
	gchar** split;
	gint split_length1;
	gint _split_size_;
	gint _tmp4_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (version != NULL, NULL);
	self = (VersionNumber*) g_object_new (object_type, NULL);
	_tmp0_ = g_strdup (version);
	_g_free0 (self->priv->originalString);
	self->priv->originalString = _tmp0_;
	_tmp1_ = g_regex_new ("([[:digit:]]*)\\.([[:digit:]]*)\\.*([[:digit:]]*)", 0, 0, &_inner_error_);
	regex = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_REGEX_ERROR) {
			goto __catch0_g_regex_error;
		}
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp3_ = _tmp2_ = g_regex_split (regex, version, 0);
	split = _tmp3_;
	split_length1 = _vala_array_length (_tmp2_);
	_split_size_ = _vala_array_length (_tmp2_);
	g_assert (split_length1 > 1);
	_tmp4_ = atoi (split[1]);
	version_number_set_major (self, _tmp4_);
	if (split_length1 > 2) {
		gint _tmp5_;
		_tmp5_ = atoi (split[2]);
		version_number_set_minor (self, _tmp5_);
	} else {
		version_number_set_minor (self, 0);
	}
	if (split_length1 > 3) {
		gint _tmp6_;
		_tmp6_ = atoi (split[3]);
		version_number_set_revision (self, _tmp6_);
	} else {
		version_number_set_revision (self, 0);
	}
	split = (_vala_array_free (split, split_length1, (GDestroyNotify) g_free), NULL);
	_g_regex_unref0 (regex);
	goto __finally0;
	__catch0_g_regex_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Error compiling regular expression!");
		exit (-1);
		_g_error_free0 (e);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	return self;
}


VersionNumber* version_number_new (const gchar* version) {
	return version_number_construct (TYPE_VERSION_NUMBER, version);
}


gboolean version_number_newerThan (VersionNumber* self, VersionNumber* other) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (other != NULL, FALSE);
	if (self->priv->_major > other->priv->_major) {
		result = TRUE;
		return result;
	} else {
		if (self->priv->_major == other->priv->_major) {
			if (self->priv->_minor > other->priv->_minor) {
				result = TRUE;
				return result;
			} else {
				if (self->priv->_minor == other->priv->_minor) {
					if (self->priv->_revision > other->priv->_revision) {
						result = TRUE;
						return result;
					}
				}
			}
		}
	}
	result = FALSE;
	return result;
}


gchar* version_number_getString (VersionNumber* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self->priv->originalString);
	result = _tmp0_;
	return result;
}


static gint version_number_get_major (VersionNumber* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_major;
	return result;
}


static void version_number_set_major (VersionNumber* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_major = value;
}


static gint version_number_get_minor (VersionNumber* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_minor;
	return result;
}


static void version_number_set_minor (VersionNumber* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_minor = value;
}


static gint version_number_get_revision (VersionNumber* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_revision;
	return result;
}


static void version_number_set_revision (VersionNumber* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_revision = value;
}


static void version_number_class_init (VersionNumberClass * klass) {
	version_number_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (VersionNumberPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_version_number_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_version_number_set_property;
	G_OBJECT_CLASS (klass)->finalize = version_number_finalize;
}


static void version_number_instance_init (VersionNumber * self) {
	self->priv = VERSION_NUMBER_GET_PRIVATE (self);
}


static void version_number_finalize (GObject* obj) {
	VersionNumber * self;
	self = VERSION_NUMBER (obj);
	_g_free0 (self->priv->originalString);
	G_OBJECT_CLASS (version_number_parent_class)->finalize (obj);
}


GType version_number_get_type (void) {
	static volatile gsize version_number_type_id__volatile = 0;
	if (g_once_init_enter (&version_number_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (VersionNumberClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) version_number_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (VersionNumber), 0, (GInstanceInitFunc) version_number_instance_init, NULL };
		GType version_number_type_id;
		version_number_type_id = g_type_register_static (G_TYPE_OBJECT, "VersionNumber", &g_define_type_info, 0);
		g_once_init_leave (&version_number_type_id__volatile, version_number_type_id);
	}
	return version_number_type_id__volatile;
}


static void _vala_version_number_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	VersionNumber * self;
	self = VERSION_NUMBER (object);
	switch (property_id) {
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_version_number_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	VersionNumber * self;
	self = VERSION_NUMBER (object);
	switch (property_id) {
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = strstr ((gchar*) self, (gchar*) needle);
	result = _tmp0_ != NULL;
	return result;
}


gint _vala_main (gchar** args, int args_length1) {
	gint result = 0;
	VersionNumber* _tmp0_ = NULL;
	VersionNumber* minimumVersion;
	gchar* _tmp1_;
	gchar* filename;
	gint _tmp2_;
	gint fd;
	struct stat stat = {0};
	struct stat _tmp3_ = {0};
	gint modificationTime;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_;
	gchar* firstLine;
	gchar* content = NULL;
	gchar* _tmp8_ = NULL;
	gboolean _tmp9_;
	gboolean _tmp10_;
	GString* _tmp15_ = NULL;
	GString* headerFile;
	gchar* _tmp16_;
	gchar* _tmp17_;
	gchar* _tmp18_ = NULL;
	gchar* _tmp19_;
	gchar* output = NULL;
	gchar* errorOutput = NULL;
	gint returnCode = 0;
	GFile* _tmp20_ = NULL;
	GFile* libPath;
	GFileEnumerator* _tmp21_ = NULL;
	GFileEnumerator* enumerator;
	GFileInfo* fileinfo = NULL;
	gint counter;
	GeeHashMap* _tmp22_ = NULL;
	GeeHashMap* symbolMap;
	GeeHashSet* _tmp23_ = NULL;
	GeeHashSet* symbolsNewerThanMinimum;
	GeeSet* _tmp59_ = NULL;
	GeeSet* _tmp60_;
	GeeIterator* _tmp61_ = NULL;
	GeeIterator* _tmp62_;
	GeeIterator* it;
	GError * _inner_error_ = NULL;
	if (args_length1 != 3) {
		fprintf (stdout, "Usage: buildlist <output path of apsymbols.h> <minimum glibc version>\n");
		result = 1;
		return result;
	}
	_tmp0_ = version_number_new (args[2]);
	minimumVersion = _tmp0_;
	_tmp1_ = g_strconcat (args[1], "/apsymbols.h", NULL);
	filename = _tmp1_;
	_tmp2_ = open (args[0], 0, (mode_t) 0);
	fd = _tmp2_;
	fstat (fd, &_tmp3_);
	stat = _tmp3_;
	modificationTime = (gint) stat.st_mtime;
	close (fd);
	_tmp4_ = version_number_getString (minimumVersion);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_strdup_printf ("/* minimum glibc %s; modification time of buildlist %d */", _tmp5_, modificationTime);
	_tmp7_ = _tmp6_;
	_g_free0 (_tmp5_);
	firstLine = _tmp7_;
	_tmp9_ = g_file_get_contents (filename, &_tmp8_, NULL, &_inner_error_);
	_g_free0 (content);
	content = _tmp8_;
	_tmp10_ = _tmp9_;
	if (_inner_error_ != NULL) {
		goto __catch2_g_error;
	}
	if (_tmp10_) {
		gchar** _tmp11_;
		gchar** _tmp12_ = NULL;
		gchar** _tmp13_;
		gint _tmp13__length1;
		gboolean _tmp14_;
		_tmp12_ = _tmp11_ = g_strsplit (content, "\n", 0);
		_tmp13_ = _tmp12_;
		_tmp13__length1 = _vala_array_length (_tmp11_);
		_tmp14_ = g_strcmp0 (_tmp13_[0], firstLine) == 0;
		_tmp13_ = (_vala_array_free (_tmp13_, _tmp13__length1, (GDestroyNotify) g_free), NULL);
		if (_tmp14_) {
			result = 0;
			_g_free0 (content);
			_g_free0 (firstLine);
			_g_free0 (filename);
			_g_object_unref0 (minimumVersion);
			return result;
		}
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (e);
	}
	__finally2:
	if (_inner_error_ != NULL) {
		_g_free0 (content);
		_g_free0 (firstLine);
		_g_free0 (filename);
		_g_object_unref0 (minimumVersion);
		goto __catch1_g_error;
	}
	_tmp15_ = g_string_new ("");
	headerFile = _tmp15_;
	_tmp16_ = g_strconcat (firstLine, "\n", NULL);
	_tmp17_ = _tmp16_;
	g_string_append (headerFile, _tmp17_);
	_g_free0 (_tmp17_);
	_tmp18_ = version_number_getString (minimumVersion);
	_tmp19_ = _tmp18_;
	fprintf (stdout, "Generating %s (glibc %s) .", filename, _tmp19_);
	_g_free0 (_tmp19_);
	fflush (stdout);
	_tmp20_ = g_file_new_for_path ("/lib/");
	libPath = _tmp20_;
	_tmp21_ = g_file_enumerate_children (libPath, G_FILE_ATTRIBUTE_STANDARD_NAME, 0, NULL, &_inner_error_);
	enumerator = _tmp21_;
	if (_inner_error_ != NULL) {
		_g_object_unref0 (libPath);
		_g_free0 (errorOutput);
		_g_free0 (output);
		_g_string_free0 (headerFile);
		_g_free0 (content);
		_g_free0 (firstLine);
		_g_free0 (filename);
		_g_object_unref0 (minimumVersion);
		goto __catch1_g_error;
	}
	counter = 0;
	_tmp22_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, TYPE_VERSION_NUMBER, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_str_hash, g_str_equal, NULL);
	symbolMap = _tmp22_;
	_tmp23_ = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, g_str_hash, g_str_equal);
	symbolsNewerThanMinimum = _tmp23_;
	while (TRUE) {
		GFileInfo* _tmp24_ = NULL;
		GFileInfo* _tmp25_;
		const gchar* _tmp26_ = NULL;
		gchar* _tmp27_;
		gchar* _tmp28_;
		gchar* _tmp29_ = NULL;
		gchar* _tmp30_ = NULL;
		gint _tmp31_;
		_tmp24_ = g_file_enumerator_next_file (enumerator, NULL, &_inner_error_);
		_tmp25_ = _tmp24_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (symbolsNewerThanMinimum);
			_g_object_unref0 (symbolMap);
			_g_object_unref0 (fileinfo);
			_g_object_unref0 (enumerator);
			_g_object_unref0 (libPath);
			_g_free0 (errorOutput);
			_g_free0 (output);
			_g_string_free0 (headerFile);
			_g_free0 (content);
			_g_free0 (firstLine);
			_g_free0 (filename);
			_g_object_unref0 (minimumVersion);
			goto __catch1_g_error;
		}
		_g_object_unref0 (fileinfo);
		fileinfo = _tmp25_;
		if (!(fileinfo != NULL)) {
			break;
		}
		counter = counter + 1;
		if ((counter % 50) == 0) {
			fprintf (stdout, ".");
			fflush (stdout);
		}
		_tmp26_ = g_file_info_get_name (fileinfo);
		_tmp27_ = g_strconcat ("objdump -T /lib/", _tmp26_, NULL);
		_tmp28_ = _tmp27_;
		g_spawn_command_line_sync (_tmp28_, &_tmp29_, &_tmp30_, &_tmp31_, &_inner_error_);
		_g_free0 (output);
		output = _tmp29_;
		_g_free0 (errorOutput);
		errorOutput = _tmp30_;
		returnCode = _tmp31_;
		_g_free0 (_tmp28_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (symbolsNewerThanMinimum);
			_g_object_unref0 (symbolMap);
			_g_object_unref0 (fileinfo);
			_g_object_unref0 (enumerator);
			_g_object_unref0 (libPath);
			_g_free0 (errorOutput);
			_g_free0 (output);
			_g_string_free0 (headerFile);
			_g_free0 (content);
			_g_free0 (firstLine);
			_g_free0 (filename);
			_g_object_unref0 (minimumVersion);
			goto __catch1_g_error;
		}
		if (returnCode == 0) {
			gchar** _tmp32_;
			gchar** _tmp33_ = NULL;
			_tmp33_ = _tmp32_ = g_strsplit (output, "\n", 0);
			{
				gchar** line_collection;
				int line_collection_length1;
				int line_it;
				line_collection = _tmp33_;
				line_collection_length1 = _vala_array_length (_tmp32_);
				for (line_it = 0; line_it < _vala_array_length (_tmp32_); line_it = line_it + 1) {
					gchar* _tmp34_;
					gchar* line;
					_tmp34_ = g_strdup (line_collection[line_it]);
					line = _tmp34_;
					{
						GRegex* _tmp35_ = NULL;
						GRegex* regex;
						gboolean _tmp36_ = FALSE;
						gboolean _tmp37_;
						_tmp35_ = g_regex_new ("(.*)(GLIBC_)([[:digit:]]\\.([[:digit:]]\\.)*[[:digit:]])(\\)?)([ ]*)(." \
"+)", 0, 0, &_inner_error_);
						regex = _tmp35_;
						if (_inner_error_ != NULL) {
							_g_free0 (line);
							line_collection = (_vala_array_free (line_collection, line_collection_length1, (GDestroyNotify) g_free), NULL);
							_g_object_unref0 (symbolsNewerThanMinimum);
							_g_object_unref0 (symbolMap);
							_g_object_unref0 (fileinfo);
							_g_object_unref0 (enumerator);
							_g_object_unref0 (libPath);
							_g_free0 (errorOutput);
							_g_free0 (output);
							_g_string_free0 (headerFile);
							_g_free0 (content);
							_g_free0 (firstLine);
							_g_free0 (filename);
							_g_object_unref0 (minimumVersion);
							goto __catch1_g_error;
						}
						_tmp37_ = g_regex_match (regex, line, 0, NULL);
						if (_tmp37_) {
							gboolean _tmp38_;
							_tmp38_ = string_contains (line, "PRIVATE");
							_tmp36_ = !_tmp38_;
						} else {
							_tmp36_ = FALSE;
						}
						if (_tmp36_) {
							gchar** _tmp39_;
							gchar** _tmp40_ = NULL;
							gchar** _tmp41_;
							gint _tmp41__length1;
							VersionNumber* _tmp42_ = NULL;
							VersionNumber* _tmp43_;
							VersionNumber* version;
							gchar** _tmp44_;
							gchar** _tmp45_ = NULL;
							gchar** _tmp46_;
							gint _tmp46__length1;
							gchar* _tmp47_;
							gchar* _tmp48_;
							gchar* symbolName;
							gpointer _tmp49_ = NULL;
							VersionNumber* versionInMap;
							gboolean _tmp58_;
							_tmp40_ = _tmp39_ = g_regex_split (regex, line, 0);
							_tmp41_ = _tmp40_;
							_tmp41__length1 = _vala_array_length (_tmp39_);
							_tmp42_ = version_number_new (_tmp41_[3]);
							_tmp43_ = _tmp42_;
							_tmp41_ = (_vala_array_free (_tmp41_, _tmp41__length1, (GDestroyNotify) g_free), NULL);
							version = _tmp43_;
							_tmp45_ = _tmp44_ = g_regex_split (regex, line, 0);
							_tmp46_ = _tmp45_;
							_tmp46__length1 = _vala_array_length (_tmp44_);
							_tmp47_ = g_strdup (_tmp46_[7]);
							_tmp48_ = _tmp47_;
							_tmp46_ = (_vala_array_free (_tmp46_, _tmp46__length1, (GDestroyNotify) g_free), NULL);
							symbolName = _tmp48_;
							_tmp49_ = gee_abstract_map_get ((GeeAbstractMap*) symbolMap, symbolName);
							versionInMap = (VersionNumber*) _tmp49_;
							if (g_strcmp0 (symbolName, "2") == 0) {
								fprintf (stdout, "%s\n", line);
							}
							if (versionInMap == NULL) {
								gee_abstract_map_set ((GeeAbstractMap*) symbolMap, symbolName, version);
							} else {
								gboolean _tmp50_ = FALSE;
								gboolean _tmp51_;
								gboolean _tmp53_ = FALSE;
								gboolean _tmp54_ = FALSE;
								gboolean _tmp55_;
								_tmp51_ = version_number_newerThan (versionInMap, minimumVersion);
								if (_tmp51_) {
									gboolean _tmp52_;
									_tmp52_ = version_number_newerThan (versionInMap, version);
									_tmp50_ = _tmp52_;
								} else {
									_tmp50_ = FALSE;
								}
								if (_tmp50_) {
									gee_abstract_map_set ((GeeAbstractMap*) symbolMap, symbolName, version);
								}
								_tmp55_ = version_number_newerThan (minimumVersion, versionInMap);
								if (_tmp55_) {
									gboolean _tmp56_;
									_tmp56_ = version_number_newerThan (version, versionInMap);
									_tmp54_ = _tmp56_;
								} else {
									_tmp54_ = FALSE;
								}
								if (_tmp54_) {
									gboolean _tmp57_;
									_tmp57_ = version_number_newerThan (minimumVersion, version);
									_tmp53_ = _tmp57_;
								} else {
									_tmp53_ = FALSE;
								}
								if (_tmp53_) {
									gee_abstract_map_set ((GeeAbstractMap*) symbolMap, symbolName, version);
								}
							}
							_tmp58_ = version_number_newerThan (version, minimumVersion);
							if (_tmp58_) {
								gee_abstract_collection_add ((GeeAbstractCollection*) symbolsNewerThanMinimum, symbolName);
							}
							_g_object_unref0 (versionInMap);
							_g_free0 (symbolName);
							_g_object_unref0 (version);
						}
						_g_regex_unref0 (regex);
						_g_free0 (line);
					}
				}
				line_collection = (_vala_array_free (line_collection, line_collection_length1, (GDestroyNotify) g_free), NULL);
			}
		}
	}
	g_string_append (headerFile, "/* apbuild embedded metadata */\n" \
"#define APBUILD_NOTE_METADATA(s)   __asm__(\".section .metadata, \\\"M" \
"S\\\", @note, 1\\n\\t.string \\\"\" s \"\\\"\\n\\t.previous\\n\\t\")\n" \
"\n" \
"#ifdef APBUILD_VERSION\n" \
"APBUILD_NOTE_METADATA(\"apbuild.version=\" APBUILD_VERSION);\n" \
"#endif\n" \
"\n" \
"/* apbuild generated symbol exclusion list */\n");
	_tmp59_ = gee_map_get_keys ((GeeMap*) symbolMap);
	_tmp60_ = _tmp59_;
	_tmp61_ = gee_iterable_iterator ((GeeIterable*) _tmp60_);
	_tmp62_ = _tmp61_;
	_g_object_unref0 (_tmp60_);
	it = _tmp62_;
	while (TRUE) {
		gboolean _tmp63_;
		gpointer _tmp64_ = NULL;
		gchar* _tmp65_;
		gboolean _tmp66_;
		gboolean _tmp67_;
		gpointer _tmp68_ = NULL;
		gchar* _tmp69_;
		gpointer _tmp70_ = NULL;
		VersionNumber* _tmp71_;
		VersionNumber* version;
		gchar* _tmp72_ = NULL;
		gchar* versionToUse;
		gboolean _tmp73_;
		gpointer _tmp77_ = NULL;
		gchar* _tmp78_;
		gpointer _tmp79_ = NULL;
		gchar* _tmp80_;
		gchar* _tmp81_ = NULL;
		gchar* _tmp82_;
		_tmp63_ = gee_iterator_next (it);
		if (!_tmp63_) {
			break;
		}
		_tmp64_ = gee_iterator_get (it);
		_tmp65_ = (gchar*) _tmp64_;
		_tmp66_ = gee_abstract_collection_contains ((GeeAbstractCollection*) symbolsNewerThanMinimum, _tmp65_);
		_tmp67_ = !_tmp66_;
		_g_free0 (_tmp65_);
		if (_tmp67_) {
			continue;
		}
		_tmp68_ = gee_iterator_get (it);
		_tmp69_ = (gchar*) _tmp68_;
		_tmp70_ = gee_abstract_map_get ((GeeAbstractMap*) symbolMap, _tmp69_);
		_tmp71_ = (VersionNumber*) _tmp70_;
		_g_free0 (_tmp69_);
		version = _tmp71_;
		_tmp72_ = version_number_getString (version);
		versionToUse = _tmp72_;
		_tmp73_ = version_number_newerThan (version, minimumVersion);
		if (_tmp73_) {
			gchar* _tmp74_ = NULL;
			gchar* _tmp75_;
			gchar* _tmp76_ = NULL;
			_tmp74_ = version_number_getString (version);
			_tmp75_ = _tmp74_;
			_tmp76_ = g_strdup_printf ("DONT_USE_THIS_VERSION_%s", _tmp75_);
			_g_free0 (versionToUse);
			versionToUse = _tmp76_;
			_g_free0 (_tmp75_);
		}
		_tmp77_ = gee_iterator_get (it);
		_tmp78_ = (gchar*) _tmp77_;
		_tmp79_ = gee_iterator_get (it);
		_tmp80_ = (gchar*) _tmp79_;
		_tmp81_ = g_strdup_printf ("__asm__(\".symver %s, %s@GLIBC_%s\");\n", _tmp78_, _tmp80_, versionToUse);
		_tmp82_ = _tmp81_;
		g_string_append (headerFile, _tmp82_);
		_g_free0 (_tmp82_);
		_g_free0 (_tmp80_);
		_g_free0 (_tmp78_);
		_g_free0 (versionToUse);
		_g_object_unref0 (version);
	}
	g_file_set_contents (filename, headerFile->str, (gssize) (-1), &_inner_error_);
	if (_inner_error_ != NULL) {
		_g_object_unref0 (it);
		_g_object_unref0 (symbolsNewerThanMinimum);
		_g_object_unref0 (symbolMap);
		_g_object_unref0 (fileinfo);
		_g_object_unref0 (enumerator);
		_g_object_unref0 (libPath);
		_g_free0 (errorOutput);
		_g_free0 (output);
		_g_string_free0 (headerFile);
		_g_free0 (content);
		_g_free0 (firstLine);
		_g_free0 (filename);
		_g_object_unref0 (minimumVersion);
		goto __catch1_g_error;
	}
	_g_object_unref0 (it);
	_g_object_unref0 (symbolsNewerThanMinimum);
	_g_object_unref0 (symbolMap);
	_g_object_unref0 (fileinfo);
	_g_object_unref0 (enumerator);
	_g_object_unref0 (libPath);
	_g_free0 (errorOutput);
	_g_free0 (output);
	_g_string_free0 (headerFile);
	_g_free0 (content);
	_g_free0 (firstLine);
	_g_free0 (filename);
	_g_object_unref0 (minimumVersion);
	goto __finally1;
	__catch1_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_warning ("buildlist.vala:207: %s", e->message);
		result = 1;
		_g_error_free0 (e);
		return result;
	}
	__finally1:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	fprintf (stdout, " OK\n");
	result = 0;
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return _vala_main (argv, argc);
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



